{"./":{"url":"./","title":"关于","keywords":"","body":"前端工程师知识图谱 前端工程师近期的环境 2019年下半年即将到来，上半年狂风暴雨般的裁员浪潮让每一位从业者背脊发凉，在经历了五六年黄金发展期后，前端开发这个行业似乎也进入了转折点。 一边听身边朋友所近期不好找工作，一边又看朋友圈认识的猎头以及一些大厂抱怨招不到合适的人，前端这个人才市场就是这么充满了矛盾与反常。 其实仔细想想，出现上述的情况很容易理解，黄金期看到前端相比较于薪资很高，导致产生了很多相关培训机构，实际上前端开发单纯从数量上已经饱和了，所以大量的初级前端工程师找不到活干，但是从另一方面看，高级前端工程师依然是凤毛麟角，高级岗的HC永远是不饱和的。 很多工程师听说前端薪资高，就去参加培训，对于技术这一块还只是停留在如何使用的阶段，不去深究为什么这么用，为什么这么实现。 目前前端人员的分布是金子塔形的，而且是底部比较长的金字塔形状。 所以进阶是大部分前端开发必须要面对的事情，现在不是能写几个页面就能找到工作的时代了，只有往上进阶才能保持职业竞争力，否则我们谁都不能保证下次裁员潮来临的时候，我们会不会成为沙滩上裸泳的人。 前端工程师的技术栈 前端社区是非常活跃的社区，几乎每过一段时间就会有新的技术或者新的开发方式变成了热点，因此前端开发者才会有了『学不动了』的梗，以及毕竟丢人的Deno留言事件。 如果要开发一个APP，目前相关的技术实现就有多种如： flutter 跨平台技术 RN 跨平台技术 (react) WEEX (vue) ionic (angular) Cordova (html/css/js) 原生(android) java …. 我们有时候看似在学很多技术，其实这些技术并不能提升你，但是给你造成了 『我学了新东西能力提升了』 的自我感觉偏差。 不要盲目追寻社区的热点，很可能捡了芝麻丢了西瓜，要仔细思考这门技术对于你本身是否有提升，而不是被布道师门『洗脑』。 静心沉淀 在这个浮躁的社会中， 我们更应该静下心来，去了解相关工具源码，项目的实现原理，有哪些优势，是否可进行重构。 By webxmsj，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-08-16 02:40:12 "},"CSS/":{"url":"CSS/","title":"README","keywords":"","body":"css 介绍 By webxmsj，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-08-16 02:40:12 "},"CSS/1-1语法.html":{"url":"CSS/1-1语法.html","title":"1-1语法","keywords":"","body":"01 这是第一章第一节 描述 By webxmsj，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-08-16 02:40:12 "},"HTML/":{"url":"HTML/","title":"README","keywords":"","body":"html 介绍 By webxmsj，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-08-16 02:40:12 "},"HTML/1-1常用meta.html":{"url":"HTML/1-1常用meta.html","title":"1-1常用meta","keywords":"","body":"常用meta H5标准声明，使用 HTML5 doctype，不区分大小写 标准的 lang 属性写法 声明文档使用的字符编码 优先使用 IE 最新版本和 Chrome 页面描述 页面关键词 网页作者 搜索引擎抓取 为移动设备添加 viewport iOS 设备 begin 添加到主屏后的标题（iOS 6 新增） 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） 设置苹果工具栏颜色 启用360浏览器的极速模式(webkit) 避免IE使用兼容模式 不让百度转码 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 微软的老式浏览器 uc强制竖屏 QQ强制竖屏 UC强制全屏 QQ强制全屏 UC应用模式 QQ应用模式 windows phone 点击无高光 设置页面不缓存 By webxmsj，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-08-16 02:40:12 "},"JS/":{"url":"JS/","title":"README","keywords":"","body":"JS 介绍 By webxmsj，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-08-16 02:40:12 "},"JS/1-1类型转换.html":{"url":"JS/1-1类型转换.html","title":"1-1类型转换","keywords":"","body":"JavaScript类型转换 JavaScript作为一门弱类型语言，我们在每天的编写代码过程中，无时无刻不在应用着值类型转换,但是很多时候我们只是在单纯的写 By webxmsj，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-08-16 02:40:12 "},"JS/1-2js中的继承.html":{"url":"JS/1-2js中的继承.html","title":"1-2js中的继承","keywords":"","body":"聊聊js中的继承(一个简单的造人项目) 我们有了大批廉价的妖精 妖精转人类实验一 // 创建一个人的类型 function Person() {}; Person.prototype.think = function(){ console.log('How to Make More Money') }; // 妖精 function Fairy() {}; // 妖精一族想要成为人类,我们尝试给他加上能够思考的能力 Fairy.prototype.think = Person.prototype.think; // 妖精中的一只狐妖 var foxFairy = new Fairy() // 我们看看它是个人吗？ assert(foxFairy instanceof Person, 'foxFairy should be a person') // false :thinking: 我们尝试将Person原型(prototype)上的think属性方法复制到Fairy的原型上作为同名方法来实现继承功能。 😅 测试结果表明，尽管我们可能已经教会了妖精思考，但是没能让妖精们成为一个人(Person)。这不是继承而是复制 我们尝试其他方案 妖精转人类实验二(原型链继承) 我们要想让妖精成为一个人，看来只能是让妖精的原型(prototype)等于一个人，这样就会形成一个链式的结构。 我们尝试修改下我们的代码 // 创建一个人的类型 function Person() {} Person.prototype.think = function(){ console.log('How to Make More Money') } // 妖精 function Fairy() {}; // 妖精一族想要成为人类,我们尝试给他加上能够思考的能力 ** Fairy.prototype = new Person() ** // 妖精中的一只狐妖 var foxFairy = new Fairy() // 我们看看它是个人吗？ assert(foxFairy instanceof Person, 'foxFairy should be a person') // true ⚠️ 大家可能会想起另外一个技巧，但强烈建议不要使用, 那就是将Fairy.prototype = new Person()改为Fairy.prototype = Person.prototype，这样做的话，Fairy原型上的任何修改都会影响到Person的原型，因为它们是引用类型，指向的是堆内存中同一个对象，这样做肯定会有不良的副作用。 :thinking: 虽然我们实现了将妖精进化成人类这么一个操作，但是呢？每一个妖精都没有特色了，想给自己起个名字都不可以吗？ 妖精转人类实验三(借用构造函数继承) 我们既要让妖精进化为一个人类，又要让其能有自己的特色，比如名字。 我们想到了借用构造函数，修改代码如下： // 创建一个人的类型 function Person(name) { this.name = name } Person.prototype.think = function(){ console.log('How to Make More Money') } function Fairy(name) { Person.call(this, name) }; // 妖精中的一只狐妖 var foxFairy = new Fairy('xiaoyao') // 我们看看它是个人吗？ assert(foxFairy.name === 'xiaoyao', 'foxFairy should has a name \"xiaoyao\"') // true assert(foxFairy instanceof Person, 'foxFairy should be a person') // false :thinking: 虽然每个妖精有了自己特色的名字，但是缺乏了人类公共的一些功能如思考，算不上一个人。 妖精转人类实验四(组合继承) // 创建一个人的类型 function Person(name) { this.name = name } Person.prototype.think = function(){ console.log('How to Make More Money') } function Fairy(name) { Person.call(this, name) }; // 具备人类公共的功能 Fairy.prototype.think = new Person(); // 妖精中的一只狐妖 var foxFairy = new Fairy('xiaoyao') // 我们看看它是个人吗？ assert(foxFairy.name === 'xiaoyao', 'foxFairy should has a name \"xiaoyao\"') // true assert(foxFairy instanceof Person, 'foxFairy should be a person') // false 既有人类思考的能力，也有自己特色的名字了, 但是调用了两次Person构造函数(耗内存) 换种思路，我们对人类进行仿制 妖精转人类实验五(原型式继承) // 创建一个人的类型 function Person(name) { this.name = name } Person.prototype.think = function(){ console.log('How to Make More Money') } // 建立一个山寨工厂，用来仿制传入的东西 function imitationUtil(obj) { function F() {}; F.prototype = obj; return new F(); } var man = new Person() // 我们依照男人(man),进行一个仿制看看得到了一个什么？ var something = imitationUtil(man) assert(foxFairy.name === 'xiaoyao', 'foxFairy should has a name \"xiaoyao\"') // false assert(foxFairy instanceof Person, 'foxFairy should be a person') // true 🔑 我们仿制出来的这个东西已经是一个人了，但是缺乏其独自的特色 妖精转人类实验六(寄生式继承) // 创建一个人的类型 function Person(name) { this.name = name } Person.prototype.think = function(){ console.log('How to Make More Money') } // 建立一个山寨工厂，用来仿制传入的东西 function imitationUtil(obj) { function F() {}; F.prototype = obj; return new F(); } function Fairy(obj, name) { var something = imitationUtil(obj) something.name = name return something; }; var man = new Person() // 妖精中的一只狐妖 var foxFairy = Fairy(man, 'xiaoyao') assert(foxFairy.name === 'xiaoyao', 'foxFairy should has a name \"xiaoyao\"') // true assert(foxFairy instanceof Person, 'foxFairy should be a person') // true 妖精转人类实验七(寄生组合式继承) // 创建一个人的类型 function Person(name) { this.name = name } Person.prototype.think = function(){ console.log('How to Make More Money') } // 建立一个山寨工厂，用来仿制传入的东西 function imitationUtil(obj) { function F() {}; F.prototype = obj; return new F(); } var semiFinished = imitationUtil(Person.prototype) function Fairy(name) { Person.call(this, name) } Fairy.prototype = semiFinished semiFinished.constructor = Fairy // 妖精中的一只狐妖 var foxFairy = new Fairy('xiaoyao') assert(foxFairy.name === 'xiaoyao', 'foxFairy should has a name \"xiaoyao\"') // true assert(foxFairy instanceof Person, 'foxFairy should be a person') // true 寄生式继承与寄生组合式继承区别 寄生式继承 在第一次调用Person构造函数时，Fairy.prototype会得到name属性(Person的实例属性), 只不过现在位于Fairy的原型中。 当调用Fairy构造函数时，又在新对象上创建了实例属性name 在获取name 属性时，实例上的name属性就会屏蔽原型中的同名属性 寄生式继承 寄生组合式继承 By webxmsj，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-08-16 02:40:12 "},"vue/":{"url":"vue/","title":"README","keywords":"","body":"vue 介绍 By webxmsj，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-08-16 02:40:12 "},"vue/1-1抽象组件.html":{"url":"vue/1-1抽象组件.html","title":"1-1抽象组件","keywords":"","body":"抽象组件即无渲染组件(如vue中自带的keep-aliave组件) 就像java中的抽象类，它本身不糊做一些事情，只是提供一些接口方法等让外部使用。后续我们可以不断扩展该组件实现更好更强大的组件。这也正是SOLID 根据SOLID的单一职责原则： 一个类应该只做一件事。 🌰栗子： 你的组件可能有一个名叫password-input的组件，它肯定呈现一个密码输入框。问题在于，当你想要在其他项目重用此组件时，你可能不得不查看组件源码修改样式或者HTML，以便能和新项目的样式或设计图保持一致。 如果你这样做就破坏了SOLID原则，也就是开闭原则。 类或者组件，应该对扩展开放，对修改关闭。 由于vue了解SOLID原则，所以它允许组件具有props、events、slots以及scoped slots，从而使组件的通信和扩展变得轻而易举。然后我们可以构建具有所有功能的组件，而无需任何样式或HTML。对于编写可重用性和高性能的代码来说真的不错。 以抽象组件的形式构建一个开关组件 抽象组件定义 // toggle.js export default { props: { on: { type: Boolean, default: false } }, render() { return this.$slots.default({ on: this.currentState, setOn: this.setOn, setOff: this.setOff, toggle: this.toggle }); }, data() { return { currentState: this.on } }, methods: { setOn() { this.currentState = true; }, setOff() { this.currentState = false; }, toggle() { this.currentState = !this.currentState } } } 抽象组件应用 开 关 import { Component, Vue, Provide } from \"vue-property-decorator\"; import Toggle from \"@/components/Toggle.js\"; // @ is an alias to /src @Component({ components: { Toggle } }) export default class High extends Vue {} .switch-text { width: 100%; height: 100%; position: absolute; padding: 0 5px; line-height: 24px; user-select: none; font-size: 14px; } .switch-text-left { text-align: left; color: #fff; left: 2px; } .switch-text-right { right: 2px; color: #7a7a7a; text-align: right; } .weui-switch { display: block; position: relative; width: 52px; height: 24px; border: 1px solid #dfdfdf; outline: 0; border-radius: 16px; box-sizing: border-box; background-color: #dfdfdf; transition: background-color 0.1s, border 0.1s; cursor: pointer; } .weui-switch:before { content: \" \"; position: absolute; top: 0; left: 0; width: 50px; height: 22px; border-radius: 15px; background-color: #fdfdfd; transition: transform 0.35s cubic-bezier(0.45, 1, 0.4, 1); } .weui-switch:after { content: \" \"; position: absolute; top: 0; left: 0; width: 22px; height: 22px; border-radius: 15px; background-color: #ffffff; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4); transition: transform 0.35s cubic-bezier(0.4, 0.4, 0.25, 1.35); } .weui-switch-on { border-color: #6f6f6f; background-color: #1add19; } .weui-switch-on:before { border-color: #1aad19; background-color: #409eff; } .weui-switch-on:after { transform: translateX(28px); } 效果示例： By webxmsj，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-08-16 02:40:12 "},"flutter/":{"url":"flutter/","title":"README","keywords":"","body":"一、flutter学习路线 10步，每一个学习步骤都以自己亲身实现写出了Demo为准，光看资料不算完成 参考flutterchina.clugflutter.dev，搭建Flutter开发环境，安装默认项目到设备 通读Dart语法一遍，要求上面所有代码，必须自己敲一遍 实现一个简单的HelloWorld页面，目的是熟悉Flutter的项目结构和StatelessWidget组件，通读Flutter的所有UI组件一遍，要求记住flutter的常用UI组件的继承关系 实现页面跳转、传参、接收返回值，目的是熟悉Navigator组件 实现一个淘宝-个人中心页面，暂不要求交互，但是页面的样式要大致实现，主要目的是熟悉基本UI组件，尤其是布局、文本、图片， 实现一个淘宝-首页，要求包含交互：下拉刷新和上拉加载更多，主要目的是熟悉复杂列表视图、滚动嵌套、手势 实现一个简单登录页面的Http请求，服务端自己写，主要目的是熟悉Flutter的输入框、Dart的异步编程(async/await/Future)、网络请求、json解析、响应式编程(StatefulWidget/setState) 实现一个简单登录页面的grpc请求，protobuf文件和服务端也自己写，主要目的是熟悉grpc插件的用法 实现读取SP的简单页面，不准用第三方插件，自己用MethodChannel实现Flutter调用原生的功能 实现Flutter项目接入宿主Android容器，主要目的是熟悉Flutter静态路由和Android原生传参给FlutterView 二、下一步的调研计划 调研必须有输出，实践性的要有代码产出，理论性的要有wiki产出，没有产出的调研，就是耍流氓 写一个国际化的demo，实现多语言切换 写一个自定义View的Demo，熟悉绘图三剑客：canvas、path、paint 写一个网络图片缓存的demo，并了解其实现原理和内存占用 阅读源码，了解Flutter的渲染机制，如何从Widget->Element->RenderObject 了解Dart的异步机制，深入理解async/await/Future的原理 原文链接 By webxmsj，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-08-16 02:40:12 "}}